`timescale 1ns / 1ps
// ============================
// spi_master_byte.v
// Mode 0, MSB-first, 8-bit transfers on demand.
// SCK generated by dividing 'clk' by (2*clk_div). Change clk_div on the fly.
// MOSI changes on SCK falling edge; MISO sampled on SCK rising edge.
// One transfer per 'start' pulse. 'busy' high while shifting 8 bits.
// ============================
module spi_master_byte
#(
  parameter DIV_INIT = 16'd250  // example default: with 100 MHz sysclk -> 100e6/(2*250)=200 kHz
)
(
  input  wire        clk,
  input  wire        rst,

  input  wire [15:0] clk_div,     // divider for SCK (half-period count)
  input  wire        start,       // pulse to start an 8-bit transaction
  input  wire [7:0]  mosi_byte,
  output reg  [7:0]  miso_byte,
  output reg         busy,
  output reg         done,        // 1 clk pulse when byte finished

  // SPI pins (CS is controlled by higher-level FSMs)
  output reg         sck,
  output reg         mosi,
  input  wire        miso
);

  reg [15:0] div_cnt;
  reg [2:0]  bit_cnt;
  reg        sck_en;         // local enable for sck toggling during an active transfer
  reg [7:0]  shifter_tx;
  reg [7:0]  shifter_rx;

  // Idle defaults
  always @(posedge clk) begin
    if (rst) begin
      sck        <= 1'b0;   // mode 0: idle low
      mosi       <= 1'b1;   // idle high on MOSI is fine
      busy       <= 1'b0;
      done       <= 1'b0;
      div_cnt    <= 16'd0;
      bit_cnt    <= 3'd0;
      sck_en     <= 1'b0;
      shifter_tx <= 8'hFF;
      shifter_rx <= 8'h00;
      miso_byte  <= 8'h00;
    end else begin
      done <= 1'b0;

      // Launch a new byte
      if (start && !busy) begin
        busy       <= 1'b1;
        sck_en     <= 1'b1;
        bit_cnt    <= 3'd7;
        shifter_tx <= mosi_byte;
        shifter_rx <= 8'h00;
        mosi       <= mosi_byte[7];  // present MSB before first falling edge
        sck        <= 1'b0;          // ensure we start from idle low
        div_cnt    <= clk_div;
      end

      // Generate SCK when active
      if (busy && sck_en) begin
        if (div_cnt == 16'd0) begin
          div_cnt <= clk_div;
          sck     <= ~sck;

          // Rising edge: sample MISO (mode 0)
          if (~sck) begin
            shifter_rx <= {shifter_rx[6:0], miso};
            if (bit_cnt == 3'd0) begin
              // after sampling LSB, next is to finish on the falling edge
            end
          end else begin
            // Falling edge: shift out next MOSI bit
            if (bit_cnt != 3'd0) begin
              bit_cnt    <= bit_cnt - 3'd1;
              shifter_tx <= {shifter_tx[6:0], 1'b1};
              mosi       <= shifter_tx[6]; // next bit
            end else begin
              // This falling edge has just shifted the last bit; complete on next rising sample already done
              // We need one more half-cycle to return SCK low; but we finish now for clean byte pacing.
              busy      <= 1'b0;
              sck_en    <= 1'b0;
              sck       <= 1'b0;  // return to idle low
              mosi      <= 1'b1;
              miso_byte <= {shifter_rx[6:0], miso};
              done      <= 1'b1;
            end
          end

        end else begin
          div_cnt <= div_cnt - 16'd1;
        end
      end
    end
  end
endmodule

